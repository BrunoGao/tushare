# å®é™…äº¤æ˜“è¡Œæƒ…ç­–ç•¥è¯„ä¼°ä¸éªŒè¯å®Œæ•´æŒ‡å—

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»å¦‚ä½•ä½¿ç”¨LJWX-Stockç³»ç»Ÿè¿›è¡ŒæŠ•èµ„ç­–ç•¥çš„è¯„ä¼°ä¸éªŒè¯ï¼Œç¡®ä¿ç­–ç•¥åœ¨å®é™…å¸‚åœºç¯å¢ƒä¸­çš„æœ‰æ•ˆæ€§ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ•°æ®è·å–å±‚     â”‚    â”‚   ç­–ç•¥å¼•æ“å±‚     â”‚    â”‚   è¯„ä¼°åˆ†æå±‚     â”‚
â”‚                â”‚    â”‚                â”‚    â”‚                â”‚
â”‚ â€¢ TuShare API   â”‚â”€â”€â”€â–¶â”‚ â€¢ ä¿¡å·ç”Ÿæˆå™¨     â”‚â”€â”€â”€â–¶â”‚ â€¢ å›æµ‹å¼•æ“      â”‚
â”‚ â€¢ å†å²è¡Œæƒ…æ•°æ®   â”‚    â”‚ â€¢ æŠ€æœ¯æŒ‡æ ‡è®¡ç®—   â”‚    â”‚ â€¢ ç»©æ•ˆè¯„ä¼°      â”‚
â”‚ â€¢ å®æ—¶ä»·æ ¼æµ     â”‚    â”‚ â€¢ ç­–ç•¥é€»è¾‘æ‰§è¡Œ   â”‚    â”‚ â€¢ é£é™©åˆ†æ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ•°æ®å­˜å‚¨å±‚     â”‚    â”‚ Walk-Forward    â”‚    â”‚   ç»“æœå±•ç¤ºå±‚     â”‚
â”‚                â”‚    â”‚   éªŒè¯æ¡†æ¶      â”‚    â”‚                â”‚
â”‚ â€¢ MySQLæ•°æ®åº“   â”‚    â”‚ â€¢ æ—¶åºäº¤å‰éªŒè¯   â”‚    â”‚ â€¢ Webä»ªè¡¨æ¿     â”‚
â”‚ â€¢ ç¼“å­˜ç³»ç»Ÿ      â”‚    â”‚ â€¢ æ ·æœ¬å¤–æµ‹è¯•     â”‚    â”‚ â€¢ APIæ¥å£      â”‚
â”‚ â€¢ æ•°æ®æ¸…æ´—      â”‚    â”‚ â€¢ ç¨³å¥æ€§åˆ†æ     â”‚    â”‚ â€¢ æŠ¥å‘Šç”Ÿæˆ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç³»ç»Ÿç»„ä»¶è¯¦è§£

#### 1. **æ•°æ®è·å–ä¸å¤„ç†** (`data/`)
- **TuShareDataExtractor**: å†å²è¡Œæƒ…æ•°æ®è·å–
- **RealTimeDataStream**: å®æ—¶ä»·æ ¼æ•°æ®æµ
- **DataValidator**: æ•°æ®è´¨é‡æ£€éªŒ
- **FeatureEngineer**: æŠ€æœ¯æŒ‡æ ‡è®¡ç®—

#### 2. **ç­–ç•¥éªŒè¯å¼•æ“** (`strategy_validation/`)
- **StrategyValidator**: ç­–ç•¥éªŒè¯ä¸»æ¡†æ¶
- **BacktestEngine**: å†å²å›æµ‹å¼•æ“
- **WalkForwardAnalysis**: æ—¶åºå‰å‘åˆ†æ
- **RiskAnalyzer**: é£é™©æŒ‡æ ‡è®¡ç®—

#### 3. **è¯„ä¼°æ¡†æ¶** (`model_evaluation/`)
- **PerformanceMetrics**: ç»©æ•ˆæŒ‡æ ‡ä½“ç³»
- **StatisticalAnalysis**: ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ
- **BenchmarkComparison**: åŸºå‡†æ¯”è¾ƒåˆ†æ
- **ReportGenerator**: è‡ªåŠ¨åŒ–æŠ¥å‘Šç”Ÿæˆ

---

## ğŸ“ˆ éªŒè¯æ–¹æ³•è®º

### å›æµ‹éªŒè¯æµç¨‹

```mermaid
graph TD
    A[å†å²æ•°æ®è·å–] --> B[æ•°æ®é¢„å¤„ç†]
    B --> C[æŠ€æœ¯æŒ‡æ ‡è®¡ç®—]
    C --> D[ç­–ç•¥ä¿¡å·ç”Ÿæˆ]
    D --> E[äº¤æ˜“æ¨¡æ‹Ÿæ‰§è¡Œ]
    E --> F[ç»©æ•ˆæŒ‡æ ‡è®¡ç®—]
    F --> G[é£é™©è¯„ä¼°åˆ†æ]
    G --> H[ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ]
    H --> I[ç»“æœæŠ¥å‘Šç”Ÿæˆ]
```

### æ ¸å¿ƒéªŒè¯åŸåˆ™

#### **1. æ—¶é—´åºåˆ—å®Œæ•´æ€§**
- âœ… ä¸¥æ ¼æŒ‰æ—¶é—´é¡ºåºå¤„ç†æ•°æ®
- âœ… é¿å…å‰ç»åå·®(Look-ahead Bias)
- âœ… è€ƒè™‘äº¤æ˜“æ»åå’Œæ‰§è¡Œå»¶è¿Ÿ
- âœ… å¤„ç†åœç‰Œã€é™¤æƒé™¤æ¯äº‹ä»¶

#### **2. æ ·æœ¬åˆ†å‰²ç­–ç•¥**
```python
# è®­ç»ƒé›†ï¼šå†å²æ•°æ®çš„70%
train_start = "2020-01-01"
train_end = "2023-06-30"

# éªŒè¯é›†ï¼šç”¨äºå‚æ•°è°ƒä¼˜ï¼Œ15%
validation_start = "2023-07-01"  
validation_end = "2023-12-31"

# æµ‹è¯•é›†ï¼šæœ€ç»ˆè¯„ä¼°ï¼Œ15%
test_start = "2024-01-01"
test_end = "2024-12-31"
```

#### **3. Walk-Forwardåˆ†æ**
- **æ»‘åŠ¨çª—å£**: æ¨¡æ‹ŸçœŸå®äº¤æ˜“ç¯å¢ƒ
- **å‚æ•°ç¨³å®šæ€§**: éªŒè¯ç­–ç•¥å‚æ•°çš„æ—¶é—´ç¨³å®šæ€§
- **é€‚åº”æ€§æµ‹è¯•**: ç­–ç•¥å¯¹å¸‚åœºå˜åŒ–çš„é€‚åº”èƒ½åŠ›

---

## ğŸ¯ è¯„ä¼°æŒ‡æ ‡ä½“ç³»

### æ”¶ç›ŠæŒ‡æ ‡

| æŒ‡æ ‡åç§° | è®¡ç®—å…¬å¼ | è§£é‡Šè¯´æ˜ | ä¼˜ç§€æ ‡å‡† |
|---------|---------|---------|---------|
| **å¹´åŒ–æ”¶ç›Šç‡** | `(æ€»æ”¶ç›Š + 1)^(252/äº¤æ˜“æ—¥æ•°) - 1` | ç­–ç•¥å¹´åŒ–è¡¨ç° | > 15% |
| **ç´¯è®¡æ”¶ç›Šç‡** | `(æœŸæœ«ä»·å€¼ - æœŸåˆä»·å€¼) / æœŸåˆä»·å€¼` | æ€»ä½“æ”¶ç›Šæ°´å¹³ | > å¸‚åœºåŸºå‡† |
| **è¶…é¢æ”¶ç›Šç‡** | `ç­–ç•¥æ”¶ç›Š - åŸºå‡†æ”¶ç›Š` | ç›¸å¯¹åŸºå‡†è¡¨ç° | > 3% |
| **ä¿¡æ¯æ¯”ç‡** | `è¶…é¢æ”¶ç›Š / è·Ÿè¸ªè¯¯å·®` | å•ä½é£é™©è¶…é¢æ”¶ç›Š | > 0.5 |

### é£é™©æŒ‡æ ‡

| æŒ‡æ ‡åç§° | è®¡ç®—å…¬å¼ | è§£é‡Šè¯´æ˜ | ä¼˜ç§€æ ‡å‡† |
|---------|---------|---------|---------|
| **å¹´åŒ–æ³¢åŠ¨ç‡** | `æ—¥æ”¶ç›Šç‡æ ‡å‡†å·® * âˆš252` | æ”¶ç›Šç‡ä¸ç¡®å®šæ€§ | < 25% |
| **æœ€å¤§å›æ’¤** | `max((å³°å€¼ - è°·å€¼) / å³°å€¼)` | æœ€å¤§äºæŸå¹…åº¦ | < 15% |
| **å¤æ™®æ¯”ç‡** | `(å¹´åŒ–æ”¶ç›Š - æ— é£é™©æ”¶ç›Š) / å¹´åŒ–æ³¢åŠ¨ç‡` | é£é™©è°ƒæ•´æ”¶ç›Š | > 1.0 |
| **å¡å°”é©¬æ¯”ç‡** | `å¹´åŒ–æ”¶ç›Š / æœ€å¤§å›æ’¤` | å›æ’¤è°ƒæ•´æ”¶ç›Š | > 1.5 |
| **ç´¢æè¯ºæ¯”ç‡** | `å¹´åŒ–æ”¶ç›Š / ä¸‹è¡Œæ ‡å‡†å·®` | ä¸‹è¡Œé£é™©è°ƒæ•´ | > 1.2 |
| **VaR (5%)** | `åˆ†ä½æ•°é£é™©ä»·å€¼` | æç«¯æŸå¤±ä¼°è®¡ | < 5% |

### äº¤æ˜“æŒ‡æ ‡

| æŒ‡æ ‡åç§° | è®¡ç®—å…¬å¼ | è§£é‡Šè¯´æ˜ | ä¼˜ç§€æ ‡å‡† |
|---------|---------|---------|---------|
| **èƒœç‡** | `ç›ˆåˆ©äº¤æ˜“æ¬¡æ•° / æ€»äº¤æ˜“æ¬¡æ•°` | äº¤æ˜“æˆåŠŸæ¦‚ç‡ | > 55% |
| **ç›ˆäºæ¯”** | `å¹³å‡ç›ˆåˆ© / å¹³å‡äºæŸ` | å•æ¬¡äº¤æ˜“æ”¶ç›Šæ¯” | > 1.5 |
| **äº¤æ˜“é¢‘ç‡** | `å¹´äº¤æ˜“æ¬¡æ•°` | ç­–ç•¥æ´»è·ƒç¨‹åº¦ | é€‚ä¸­ |
| **å¹³å‡æŒæœ‰æœŸ** | `æ€»æŒæœ‰å¤©æ•° / äº¤æ˜“æ¬¡æ•°` | èµ„é‡‘å‘¨è½¬æ•ˆç‡ | ä¸ç­–ç•¥åŒ¹é… |

---

## ğŸ’¹ æ•°æ®è·å–ä¸å¤„ç†

### çœŸå®è¡Œæƒ…æ•°æ®æº

#### **ä¸»è¦æ•°æ®æä¾›å•†**
```python
# TuShare Pro - ä¸­å›½è‚¡å¸‚æ•°æ®
import tushare as ts
ts.set_token('your_token')
pro = ts.pro_api()

# æ—¥çº¿æ•°æ®è·å–
daily_data = pro.daily(
    ts_code='000001.SZ',
    start_date='20240101',
    end_date='20241231'
)

# åˆ†é’Ÿçº§æ•°æ®ï¼ˆVIPç”¨æˆ·ï¼‰
minute_data = pro.stk_mins(
    ts_code='000001.SZ',
    freq='1min',
    start_date='20241201 09:30:00',
    end_date='20241201 15:00:00'
)
```

#### **æ•°æ®è´¨é‡æ£€éªŒ**
```python
class DataValidator:
    """æ•°æ®è´¨é‡éªŒè¯å™¨"""
    
    def validate_completeness(self, data: pd.DataFrame) -> bool:
        """æ£€æŸ¥æ•°æ®å®Œæ•´æ€§"""
        # æ£€æŸ¥ç¼ºå¤±å€¼
        missing_ratio = data.isnull().sum() / len(data)
        if missing_ratio.max() > 0.05:  # ç¼ºå¤±è¶…è¿‡5%
            return False
            
        # æ£€æŸ¥ä»·æ ¼åˆç†æ€§
        if (data['high'] < data['low']).any():
            return False
            
        if (data['close'] > data['high']).any():
            return False
            
        return True
    
    def detect_anomalies(self, data: pd.DataFrame) -> pd.DataFrame:
        """å¼‚å¸¸å€¼æ£€æµ‹"""
        # ä»·æ ¼è·³è·ƒæ£€æµ‹
        returns = data['close'].pct_change()
        z_scores = np.abs((returns - returns.mean()) / returns.std())
        
        # æ ‡è®°å¼‚å¸¸å€¼ï¼ˆZ-score > 4ï¼‰
        data['is_anomaly'] = z_scores > 4
        
        return data
```

### æŠ€æœ¯æŒ‡æ ‡è®¡ç®—

#### **ä¸»è¦æŠ€æœ¯æŒ‡æ ‡åº“**
```python
class TechnicalIndicators:
    """æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨"""
    
    @staticmethod
    def rsi(prices: pd.Series, period: int = 14) -> pd.Series:
        """ç›¸å¯¹å¼ºå¼±æŒ‡æ•°"""
        delta = prices.diff()
        gain = delta.where(delta > 0, 0).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))
    
    @staticmethod
    def macd(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> tuple:
        """MACDæŒ‡æ ‡"""
        ema_fast = prices.ewm(span=fast).mean()
        ema_slow = prices.ewm(span=slow).mean()
        macd_line = ema_fast - ema_slow
        signal_line = macd_line.ewm(span=signal).mean()
        histogram = macd_line - signal_line
        return macd_line, signal_line, histogram
    
    @staticmethod
    def bollinger_bands(prices: pd.Series, window: int = 20, num_std: float = 2) -> tuple:
        """å¸ƒæ—å¸¦"""
        sma = prices.rolling(window=window).mean()
        std = prices.rolling(window=window).std()
        upper_band = sma + (std * num_std)
        lower_band = sma - (std * num_std)
        return upper_band, sma, lower_band
```

---

## ğŸ› ï¸ ç­–ç•¥éªŒè¯å®ç°

### å®Œæ•´éªŒè¯ä»£ç æ¡†æ¶

```python
#!/usr/bin/env python3
"""
ç­–ç•¥éªŒè¯æ ¸å¿ƒå¼•æ“
å®ç°å®Œæ•´çš„ç­–ç•¥å›æµ‹ã€è¯„ä¼°å’Œåˆ†æåŠŸèƒ½
"""

import pandas as pd
import numpy as np
import tushare as ts
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
import logging
from dataclasses import dataclass
import json

@dataclass
class StrategyConfig:
    """ç­–ç•¥é…ç½®"""
    name: str
    description: str
    parameters: Dict[str, Any]
    risk_params: Dict[str, float]
    benchmark: str = "000300.SH"  # æ²ªæ·±300æŒ‡æ•°

@dataclass
class ValidationResult:
    """éªŒè¯ç»“æœ"""
    strategy_name: str
    test_period: str
    total_return: float
    annualized_return: float
    volatility: float
    sharpe_ratio: float
    max_drawdown: float
    calmar_ratio: float
    win_rate: float
    profit_loss_ratio: float
    total_trades: int
    benchmark_return: float
    excess_return: float
    information_ratio: float
    detailed_trades: List[Dict]
    monthly_returns: List[float]
    drawdown_series: List[float]

class AdvancedStrategyValidator:
    """é«˜çº§ç­–ç•¥éªŒè¯å™¨"""
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.logger = self._setup_logger()
        self._init_data_source()
    
    def _setup_logger(self) -> logging.Logger:
        """è®¾ç½®æ—¥å¿—ç³»ç»Ÿ"""
        logger = logging.getLogger(f"validator_{self.config.name}")
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
        return logger
    
    def _init_data_source(self):
        """åˆå§‹åŒ–æ•°æ®æº"""
        try:
            ts.set_token(config.TS_TOKEN)
            self.pro = ts.pro_api()
            self.logger.info("æ•°æ®æºåˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            self.logger.error(f"æ•°æ®æºåˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    def comprehensive_validation(self, 
                                stock_codes: List[str],
                                start_date: str,
                                end_date: str,
                                strategy_func: callable) -> ValidationResult:
        """
        ç»¼åˆç­–ç•¥éªŒè¯
        
        Args:
            stock_codes: æµ‹è¯•è‚¡ç¥¨ä»£ç åˆ—è¡¨
            start_date: å¼€å§‹æ—¥æœŸ (YYYY-MM-DD)
            end_date: ç»“æŸæ—¥æœŸ (YYYY-MM-DD)
            strategy_func: ç­–ç•¥å‡½æ•°ï¼Œè¿”å›äº¤æ˜“ä¿¡å·
            
        Returns:
            ValidationResult: è¯¦ç»†éªŒè¯ç»“æœ
        """
        self.logger.info(f"å¼€å§‹éªŒè¯ç­–ç•¥: {self.config.name}")
        self.logger.info(f"æµ‹è¯•æœŸé—´: {start_date} è‡³ {end_date}")
        self.logger.info(f"æµ‹è¯•è‚¡ç¥¨: {len(stock_codes)} åª")
        
        # 1. æ•°æ®è·å–ä¸é¢„å¤„ç†
        all_data = self._prepare_data(stock_codes, start_date, end_date)
        if not all_data:
            raise ValueError("æ— æ³•è·å–æœ‰æ•ˆçš„å†å²æ•°æ®")
        
        # 2. ç­–ç•¥ä¿¡å·ç”Ÿæˆ
        all_signals = {}
        for stock_code, data in all_data.items():
            signals = strategy_func(data, self.config.parameters)
            all_signals[stock_code] = signals
        
        # 3. äº¤æ˜“æ¨¡æ‹Ÿæ‰§è¡Œ
        portfolio_performance = self._simulate_trading(all_data, all_signals)
        
        # 4. åŸºå‡†æ•°æ®è·å–
        benchmark_performance = self._get_benchmark_performance(start_date, end_date)
        
        # 5. ç»©æ•ˆæŒ‡æ ‡è®¡ç®—
        metrics = self._calculate_comprehensive_metrics(
            portfolio_performance, 
            benchmark_performance
        )
        
        # 6. ç”ŸæˆéªŒè¯ç»“æœ
        result = self._generate_validation_result(
            metrics, 
            portfolio_performance,
            start_date,
            end_date
        )
        
        self.logger.info(f"éªŒè¯å®Œæˆ - å¹´åŒ–æ”¶ç›Š: {result.annualized_return:.2%}, "
                        f"å¤æ™®æ¯”ç‡: {result.sharpe_ratio:.2f}")
        
        return result
    
    def _prepare_data(self, stock_codes: List[str], start_date: str, end_date: str) -> Dict[str, pd.DataFrame]:
        """å‡†å¤‡å†å²æ•°æ®"""
        all_data = {}
        
        for stock_code in stock_codes:
            try:
                # è·å–æ—¥çº¿æ•°æ®
                data = self.pro.daily(
                    ts_code=stock_code,
                    start_date=start_date.replace('-', ''),
                    end_date=end_date.replace('-', '')
                )
                
                if data.empty:
                    continue
                
                # æ•°æ®é¢„å¤„ç†
                data['trade_date'] = pd.to_datetime(data['trade_date'])
                data = data.sort_values('trade_date').reset_index(drop=True)
                
                # æ·»åŠ æŠ€æœ¯æŒ‡æ ‡
                data = self._add_technical_indicators(data)
                
                # æ•°æ®è´¨é‡éªŒè¯
                if self._validate_data_quality(data):
                    all_data[stock_code] = data
                
            except Exception as e:
                self.logger.warning(f"è·å– {stock_code} æ•°æ®å¤±è´¥: {e}")
                continue
        
        return all_data
    
    def _add_technical_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """æ·»åŠ æŠ€æœ¯æŒ‡æ ‡"""
        # RSI
        data['rsi'] = self._calculate_rsi(data['close'])
        
        # MACD
        macd, signal, histogram = self._calculate_macd(data['close'])
        data['macd'] = macd
        data['macd_signal'] = signal
        data['macd_histogram'] = histogram
        
        # å¸ƒæ—å¸¦
        upper, middle, lower = self._calculate_bollinger_bands(data['close'])
        data['bb_upper'] = upper
        data['bb_middle'] = middle
        data['bb_lower'] = lower
        
        # ç§»åŠ¨å¹³å‡
        data['ma_5'] = data['close'].rolling(5).mean()
        data['ma_20'] = data['close'].rolling(20).mean()
        data['ma_60'] = data['close'].rolling(60).mean()
        
        # æˆäº¤é‡æŒ‡æ ‡
        data['volume_ma'] = data['vol'].rolling(20).mean()
        data['volume_ratio'] = data['vol'] / data['volume_ma']
        
        return data
    
    def _simulate_trading(self, all_data: Dict[str, pd.DataFrame], all_signals: Dict[str, List]) -> Dict:
        """æ¨¡æ‹Ÿäº¤æ˜“æ‰§è¡Œ"""
        portfolio = {
            'equity_curve': [],
            'trades': [],
            'positions': {},
            'cash': 100000,  # åˆå§‹èµ„é‡‘10ä¸‡
            'total_value': 100000
        }
        
        # è·å–æ‰€æœ‰äº¤æ˜“æ—¥
        all_dates = set()
        for data in all_data.values():
            all_dates.update(data['trade_date'])
        all_dates = sorted(list(all_dates))
        
        # é€æ—¥æ¨¡æ‹Ÿäº¤æ˜“
        for date in all_dates:
            daily_value = self._process_daily_trading(
                portfolio, all_data, all_signals, date
            )
            portfolio['equity_curve'].append({
                'date': date,
                'total_value': daily_value,
                'cash': portfolio['cash'],
                'positions_value': daily_value - portfolio['cash']
            })
        
        return portfolio
    
    def _calculate_comprehensive_metrics(self, portfolio: Dict, benchmark: pd.DataFrame) -> Dict:
        """è®¡ç®—ç»¼åˆç»©æ•ˆæŒ‡æ ‡"""
        equity_curve = pd.DataFrame(portfolio['equity_curve'])
        equity_curve['returns'] = equity_curve['total_value'].pct_change()
        
        # åŸºç¡€æ”¶ç›ŠæŒ‡æ ‡
        total_return = (equity_curve['total_value'].iloc[-1] / equity_curve['total_value'].iloc[0]) - 1
        annualized_return = (1 + total_return) ** (252 / len(equity_curve)) - 1
        
        # é£é™©æŒ‡æ ‡
        volatility = equity_curve['returns'].std() * np.sqrt(252)
        
        # æœ€å¤§å›æ’¤
        cummax = equity_curve['total_value'].cummax()
        drawdown = (equity_curve['total_value'] - cummax) / cummax
        max_drawdown = abs(drawdown.min())
        
        # å¤æ™®æ¯”ç‡
        excess_returns = equity_curve['returns'] - 0.03/252  # å‡è®¾æ— é£é™©æ”¶ç›Šç‡3%
        sharpe_ratio = excess_returns.mean() / excess_returns.std() * np.sqrt(252) if excess_returns.std() != 0 else 0
        
        # å¡å°”é©¬æ¯”ç‡
        calmar_ratio = annualized_return / max_drawdown if max_drawdown != 0 else 0
        
        # äº¤æ˜“æŒ‡æ ‡
        trades = portfolio['trades']
        profitable_trades = [t for t in trades if t['return'] > 0]
        win_rate = len(profitable_trades) / len(trades) if trades else 0
        
        avg_profit = np.mean([t['return'] for t in profitable_trades]) if profitable_trades else 0
        avg_loss = np.mean([t['return'] for t in trades if t['return'] < 0]) if any(t['return'] < 0 for t in trades) else 1
        profit_loss_ratio = abs(avg_profit / avg_loss) if avg_loss != 0 else 0
        
        # åŸºå‡†æ¯”è¾ƒ
        if not benchmark.empty:
            benchmark_return = (benchmark['close'].iloc[-1] / benchmark['close'].iloc[0]) - 1
            excess_return = total_return - benchmark_return
            
            # ä¿¡æ¯æ¯”ç‡
            benchmark_returns = benchmark['close'].pct_change().dropna()
            if len(benchmark_returns) == len(equity_curve['returns'].dropna()):
                tracking_error = (equity_curve['returns'].dropna() - benchmark_returns).std() * np.sqrt(252)
                information_ratio = excess_return / tracking_error if tracking_error != 0 else 0
            else:
                information_ratio = 0
        else:
            benchmark_return = 0
            excess_return = total_return
            information_ratio = 0
        
        return {
            'total_return': total_return,
            'annualized_return': annualized_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'calmar_ratio': calmar_ratio,
            'win_rate': win_rate,
            'profit_loss_ratio': profit_loss_ratio,
            'total_trades': len(trades),
            'benchmark_return': benchmark_return,
            'excess_return': excess_return,
            'information_ratio': information_ratio,
            'equity_curve': equity_curve,
            'drawdown_series': drawdown.tolist()
        }

# ç­–ç•¥ç¤ºä¾‹å®ç°
def rsi_mean_reversion_strategy(data: pd.DataFrame, params: Dict) -> List[Dict]:
    """RSIå‡å€¼å›å½’ç­–ç•¥"""
    signals = []
    position = None
    
    rsi_oversold = params.get('rsi_oversold', 30)
    rsi_overbought = params.get('rsi_overbought', 70)
    max_holding_days = params.get('max_holding_days', 30)
    
    for i in range(1, len(data)):
        current_rsi = data.iloc[i]['rsi']
        prev_rsi = data.iloc[i-1]['rsi']
        
        # ä¹°å…¥ä¿¡å·
        if position is None and prev_rsi < rsi_oversold and current_rsi > rsi_oversold:
            signals.append({
                'type': 'buy',
                'date': data.iloc[i]['trade_date'],
                'price': data.iloc[i]['close'],
                'index': i
            })
            position = 'long'
        
        # å–å‡ºä¿¡å·
        elif position == 'long' and (
            current_rsi > rsi_overbought or 
            (len(signals) > 0 and i - signals[-1]['index'] > max_holding_days)
        ):
            signals.append({
                'type': 'sell',
                'date': data.iloc[i]['trade_date'],
                'price': data.iloc[i]['close'],
                'index': i
            })
            position = None
    
    return signals

# ä½¿ç”¨ç¤ºä¾‹
def run_strategy_validation():
    """è¿è¡Œç­–ç•¥éªŒè¯"""
    
    # é…ç½®ç­–ç•¥
    strategy_config = StrategyConfig(
        name="RSIå‡å€¼å›å½’ç­–ç•¥",
        description="åŸºäºRSIæŒ‡æ ‡çš„è¶…ä¹°è¶…å–äº¤æ˜“ç­–ç•¥",
        parameters={
            'rsi_oversold': 25,
            'rsi_overbought': 75,
            'max_holding_days': 25
        },
        risk_params={
            'max_position_size': 0.2,  # å•ä¸ªè‚¡ç¥¨æœ€å¤§ä»“ä½20%
            'stop_loss': 0.08,         # æ­¢æŸ8%
            'take_profit': 0.15        # æ­¢ç›ˆ15%
        }
    )
    
    # åˆå§‹åŒ–éªŒè¯å™¨
    validator = AdvancedStrategyValidator(strategy_config)
    
    # æµ‹è¯•è‚¡ç¥¨æ± 
    test_stocks = [
        '000001.SZ', '000002.SZ', '600036.SH', 
        '600519.SH', '000858.SZ', '002415.SZ'
    ]
    
    # æ‰§è¡ŒéªŒè¯
    result = validator.comprehensive_validation(
        stock_codes=test_stocks,
        start_date='2023-01-01',
        end_date='2024-12-31',
        strategy_func=rsi_mean_reversion_strategy
    )
    
    # è¾“å‡ºç»“æœ
    print("="*60)
    print(f"ç­–ç•¥éªŒè¯æŠ¥å‘Š: {result.strategy_name}")
    print("="*60)
    print(f"æµ‹è¯•æœŸé—´: {result.test_period}")
    print(f"æ€»æ”¶ç›Šç‡: {result.total_return:.2%}")
    print(f"å¹´åŒ–æ”¶ç›Šç‡: {result.annualized_return:.2%}")
    print(f"å¹´åŒ–æ³¢åŠ¨ç‡: {result.volatility:.2%}")
    print(f"å¤æ™®æ¯”ç‡: {result.sharpe_ratio:.2f}")
    print(f"æœ€å¤§å›æ’¤: {result.max_drawdown:.2%}")
    print(f"å¡å°”é©¬æ¯”ç‡: {result.calmar_ratio:.2f}")
    print(f"èƒœç‡: {result.win_rate:.2%}")
    print(f"ç›ˆäºæ¯”: {result.profit_loss_ratio:.2f}")
    print(f"æ€»äº¤æ˜“æ¬¡æ•°: {result.total_trades}")
    print(f"åŸºå‡†æ”¶ç›Šç‡: {result.benchmark_return:.2%}")
    print(f"è¶…é¢æ”¶ç›Šç‡: {result.excess_return:.2%}")
    print(f"ä¿¡æ¯æ¯”ç‡: {result.information_ratio:.2f}")
    
    return result

if __name__ == "__main__":
    result = run_strategy_validation()
```

---

## ğŸ¨ é«˜çº§åˆ†ææŠ€æœ¯

### Walk-Forwardåˆ†æå®ç°

```python
class WalkForwardValidator:
    """Walk-ForwardéªŒè¯å™¨"""
    
    def __init__(self, window_size: int = 252, step_size: int = 21):
        self.window_size = window_size  # è®­ç»ƒçª—å£å¤§å°ï¼ˆäº¤æ˜“æ—¥ï¼‰
        self.step_size = step_size      # æ­¥è¿›å¤§å°
    
    def validate(self, data: pd.DataFrame, strategy_func: callable, params: Dict) -> Dict:
        """æ‰§è¡ŒWalk-Forwardåˆ†æ"""
        results = []
        
        start_idx = self.window_size
        while start_idx + self.step_size < len(data):
            # è®­ç»ƒæœŸæ•°æ®
            train_data = data.iloc[start_idx-self.window_size:start_idx]
            
            # æµ‹è¯•æœŸæ•°æ®
            test_data = data.iloc[start_idx:start_idx+self.step_size]
            
            # å‚æ•°ä¼˜åŒ–ï¼ˆå¯é€‰ï¼‰
            optimized_params = self._optimize_parameters(train_data, strategy_func, params)
            
            # æ ·æœ¬å¤–æµ‹è¯•
            test_result = self._test_strategy(test_data, strategy_func, optimized_params)
            
            results.append({
                'train_period': (train_data['trade_date'].iloc[0], train_data['trade_date'].iloc[-1]),
                'test_period': (test_data['trade_date'].iloc[0], test_data['trade_date'].iloc[-1]),
                'params': optimized_params,
                'performance': test_result
            })
            
            start_idx += self.step_size
        
        return self._analyze_walk_forward_results(results)
```

### è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ

```python
class MonteCarloValidator:
    """è’™ç‰¹å¡æ´›éªŒè¯å™¨"""
    
    def simulate_strategy_robustness(self, 
                                   strategy_returns: List[float], 
                                   n_simulations: int = 10000) -> Dict:
        """æ¨¡æ‹Ÿç­–ç•¥ç¨³å¥æ€§"""
        
        simulation_results = []
        
        for _ in range(n_simulations):
            # éšæœºé‡é‡‡æ ·æ”¶ç›Šåºåˆ—
            simulated_returns = np.random.choice(
                strategy_returns, 
                size=len(strategy_returns), 
                replace=True
            )
            
            # è®¡ç®—æ¨¡æ‹Ÿçš„ç´¯è®¡æ”¶ç›Š
            cumulative_return = (1 + np.array(simulated_returns)).prod() - 1
            max_drawdown = self._calculate_max_drawdown(simulated_returns)
            sharpe_ratio = self._calculate_sharpe_ratio(simulated_returns)
            
            simulation_results.append({
                'cumulative_return': cumulative_return,
                'max_drawdown': max_drawdown,
                'sharpe_ratio': sharpe_ratio
            })
        
        return self._analyze_monte_carlo_results(simulation_results)
```

---

## ğŸ“Š ç»“æœå±•ç¤ºä¸æŠ¥å‘Š

### è‡ªåŠ¨åŒ–æŠ¥å‘Šç”Ÿæˆ

```python
class StrategyReport:
    """ç­–ç•¥æŠ¥å‘Šç”Ÿæˆå™¨"""
    
    def generate_comprehensive_report(self, validation_result: ValidationResult) -> str:
        """ç”Ÿæˆç»¼åˆæŠ¥å‘Š"""
        
        report = f"""
# {validation_result.strategy_name} éªŒè¯æŠ¥å‘Š

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯
- **æµ‹è¯•æœŸé—´**: {validation_result.test_period}
- **æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸ“ˆ æ”¶ç›Šè¡¨ç°
| æŒ‡æ ‡ | æ•°å€¼ | è¯„çº§ |
|-----|------|------|
| æ€»æ”¶ç›Šç‡ | {validation_result.total_return:.2%} | {self._rate_performance(validation_result.total_return, 'return')} |
| å¹´åŒ–æ”¶ç›Šç‡ | {validation_result.annualized_return:.2%} | {self._rate_performance(validation_result.annualized_return, 'annual_return')} |
| è¶…é¢æ”¶ç›Šç‡ | {validation_result.excess_return:.2%} | {self._rate_performance(validation_result.excess_return, 'excess_return')} |

## ğŸ¯ é£é™©æŒ‡æ ‡
| æŒ‡æ ‡ | æ•°å€¼ | è¯„çº§ |
|-----|------|------|
| å¹´åŒ–æ³¢åŠ¨ç‡ | {validation_result.volatility:.2%} | {self._rate_performance(validation_result.volatility, 'volatility')} |
| æœ€å¤§å›æ’¤ | {validation_result.max_drawdown:.2%} | {self._rate_performance(validation_result.max_drawdown, 'drawdown')} |
| å¤æ™®æ¯”ç‡ | {validation_result.sharpe_ratio:.2f} | {self._rate_performance(validation_result.sharpe_ratio, 'sharpe')} |

## ğŸ’¼ äº¤æ˜“ç»Ÿè®¡
- **æ€»äº¤æ˜“æ¬¡æ•°**: {validation_result.total_trades}
- **èƒœç‡**: {validation_result.win_rate:.2%}
- **ç›ˆäºæ¯”**: {validation_result.profit_loss_ratio:.2f}

## ğŸ“ ç­–ç•¥è¯„ä¼°ç»“è®º
{self._generate_conclusion(validation_result)}

## ğŸ’¡ ä¼˜åŒ–å»ºè®®
{self._generate_recommendations(validation_result)}
"""
        
        return report
    
    def _rate_performance(self, value: float, metric_type: str) -> str:
        """æ€§èƒ½è¯„çº§"""
        rating_criteria = {
            'annual_return': [(0.15, 'ä¼˜ç§€'), (0.10, 'è‰¯å¥½'), (0.05, 'ä¸€èˆ¬'), (0, 'å·®')],
            'sharpe': [(1.5, 'ä¼˜ç§€'), (1.0, 'è‰¯å¥½'), (0.5, 'ä¸€èˆ¬'), (0, 'å·®')],
            'drawdown': [(0.10, 'å·®'), (0.15, 'ä¸€èˆ¬'), (0.25, 'è‰¯å¥½'), (1, 'ä¼˜ç§€')],
            'volatility': [(0.15, 'ä¼˜ç§€'), (0.20, 'è‰¯å¥½'), (0.30, 'ä¸€èˆ¬'), (1, 'å·®')]
        }
        
        criteria = rating_criteria.get(metric_type, [(0, 'ä¸€èˆ¬')])
        
        for threshold, rating in criteria:
            if (metric_type in ['drawdown', 'volatility'] and value <= threshold) or \
               (metric_type not in ['drawdown', 'volatility'] and value >= threshold):
                return rating
        
        return 'å·®'
```

---

## ğŸ”§ å®æˆ˜åº”ç”¨ç¤ºä¾‹

### å¤šç­–ç•¥ç»„åˆéªŒè¯

```python
def validate_strategy_portfolio():
    """å¤šç­–ç•¥ç»„åˆéªŒè¯"""
    
    strategies = [
        {
            'name': 'RSIå‡å€¼å›å½’',
            'func': rsi_mean_reversion_strategy,
            'params': {'rsi_oversold': 25, 'rsi_overbought': 75},
            'weight': 0.4
        },
        {
            'name': 'MACDè¶‹åŠ¿è·Ÿè¸ª', 
            'func': macd_trend_strategy,
            'params': {'fast': 12, 'slow': 26, 'signal': 9},
            'weight': 0.3
        },
        {
            'name': 'å¸ƒæ—å¸¦çªç ´',
            'func': bollinger_breakout_strategy, 
            'params': {'window': 20, 'num_std': 2},
            'weight': 0.3
        }
    ]
    
    # åˆ†åˆ«éªŒè¯å„ç­–ç•¥
    individual_results = []
    for strategy in strategies:
        config = StrategyConfig(
            name=strategy['name'],
            description=f"{strategy['name']}ç­–ç•¥éªŒè¯",
            parameters=strategy['params'],
            risk_params={'max_position_size': 0.1}
        )
        
        validator = AdvancedStrategyValidator(config)
        result = validator.comprehensive_validation(
            stock_codes=['000001.SZ', '000002.SZ', '600036.SH'],
            start_date='2023-01-01',
            end_date='2024-12-31',
            strategy_func=strategy['func']
        )
        
        individual_results.append(result)
    
    # ç»„åˆç­–ç•¥éªŒè¯
    portfolio_result = validate_combined_portfolio(strategies, individual_results)
    
    return individual_results, portfolio_result
```

### å®ç›˜æ¨¡æ‹Ÿäº¤æ˜“

```python
class PaperTradingEngine:
    """çº¸é¢äº¤æ˜“å¼•æ“"""
    
    def __init__(self, initial_capital: float = 100000):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.positions = {}
        self.trade_history = []
        self.daily_pnl = []
    
    def execute_signal(self, signal: Dict, current_price: float):
        """æ‰§è¡Œäº¤æ˜“ä¿¡å·"""
        stock_code = signal['stock_code']
        signal_type = signal['type']
        timestamp = signal['timestamp']
        
        if signal_type == 'buy':
            self._execute_buy(stock_code, current_price, timestamp)
        elif signal_type == 'sell':
            self._execute_sell(stock_code, current_price, timestamp)
    
    def _execute_buy(self, stock_code: str, price: float, timestamp: datetime):
        """æ‰§è¡Œä¹°å…¥"""
        if stock_code not in self.positions:
            # è®¡ç®—ä¹°å…¥æ•°é‡ï¼ˆå›ºå®šé‡‘é¢ï¼‰
            trade_amount = min(10000, self.current_capital * 0.1)  # æœ€å¤š10%ä»“ä½
            shares = int(trade_amount / price / 100) * 100  # æ•´ç™¾è‚¡
            
            if shares > 0:
                cost = shares * price
                self.current_capital -= cost
                
                self.positions[stock_code] = {
                    'shares': shares,
                    'avg_price': price,
                    'entry_time': timestamp
                }
                
                self.trade_history.append({
                    'stock_code': stock_code,
                    'type': 'buy',
                    'shares': shares,
                    'price': price,
                    'timestamp': timestamp,
                    'cost': cost
                })
    
    def _execute_sell(self, stock_code: str, price: float, timestamp: datetime):
        """æ‰§è¡Œå–å‡º"""
        if stock_code in self.positions:
            position = self.positions[stock_code]
            shares = position['shares']
            proceeds = shares * price
            
            self.current_capital += proceeds
            
            # è®¡ç®—æ”¶ç›Š
            cost_basis = shares * position['avg_price']
            pnl = proceeds - cost_basis
            pnl_pct = pnl / cost_basis
            
            self.trade_history.append({
                'stock_code': stock_code,
                'type': 'sell',
                'shares': shares,
                'price': price,
                'timestamp': timestamp,
                'proceeds': proceeds,
                'pnl': pnl,
                'pnl_pct': pnl_pct,
                'holding_days': (timestamp - position['entry_time']).days
            })
            
            # æ¸…é™¤æŒä»“
            del self.positions[stock_code]
    
    def get_portfolio_status(self) -> Dict:
        """è·å–ç»„åˆçŠ¶æ€"""
        total_value = self.current_capital
        
        # è®¡ç®—æŒä»“å¸‚å€¼ï¼ˆéœ€è¦å®æ—¶ä»·æ ¼ï¼‰
        positions_value = 0
        for stock_code, position in self.positions.items():
            current_price = self._get_current_price(stock_code)  # è·å–å½“å‰ä»·æ ¼
            positions_value += position['shares'] * current_price
        
        total_value += positions_value
        
        return {
            'total_value': total_value,
            'cash': self.current_capital,
            'positions_value': positions_value,
            'total_pnl': total_value - self.initial_capital,
            'total_return': (total_value - self.initial_capital) / self.initial_capital,
            'positions': self.positions,
            'trade_count': len([t for t in self.trade_history if t['type'] == 'sell'])
        }
```

---

## ğŸš€ æœ€ä½³å®è·µä¸æ³¨æ„äº‹é¡¹

### âœ… éªŒè¯æœ€ä½³å®è·µ

1. **æ•°æ®è´¨é‡æ§åˆ¶**
   - ä½¿ç”¨å¤šä¸ªæ•°æ®æºäº¤å‰éªŒè¯
   - å¤„ç†åˆ†çº¢ã€æ‹†è‚¡ç­‰å…¬å¸è¡Œä¸º
   - åŠæ—¶æ›´æ–°å¼‚å¸¸æ•°æ®

2. **å›æµ‹åå·®é¿å…**
   - ä¸¥æ ¼éµå¾ªæ—¶é—´é¡ºåº
   - è€ƒè™‘äº¤æ˜“æˆæœ¬å’Œæ»‘ç‚¹
   - é¿å…è¿‡åº¦æ‹Ÿåˆ

3. **é£é™©ç®¡ç†é›†æˆ**
   - è®¾ç½®åˆç†çš„æ­¢æŸæ­¢ç›ˆ
   - æ§åˆ¶å•ä¸ªæ ‡çš„æœ€å¤§ä»“ä½
   - åˆ†æ•£åŒ–æŠ•èµ„é™ä½é›†ä¸­åº¦é£é™©

4. **åŠ¨æ€å‚æ•°è°ƒæ•´**
   - å®šæœŸé‡æ–°ä¼˜åŒ–å‚æ•°
   - ç›‘æ§ç­–ç•¥è¡°å‡æƒ…å†µ
   - é€‚åº”å¸‚åœºç¯å¢ƒå˜åŒ–

### âš ï¸ å¸¸è§é™·é˜±

1. **å¹¸å­˜è€…åå·®**: åªæµ‹è¯•ä»åœ¨äº¤æ˜“çš„è‚¡ç¥¨
2. **å‰ç»åå·®**: ä½¿ç”¨æœªæ¥ä¿¡æ¯è¿›è¡Œå†³ç­–
3. **æ•°æ®æŒ–æ˜åå·®**: è¿‡åº¦ä¼˜åŒ–å†å²æ•°æ®
4. **äº¤æ˜“æˆæœ¬å¿½ç•¥**: æœªè€ƒè™‘å®é™…äº¤æ˜“è´¹ç”¨
5. **æµåŠ¨æ€§é—®é¢˜**: å¿½ç•¥å¤§èµ„é‡‘å¯¹å¸‚åœºçš„å†²å‡»

---

## ğŸ“š æ‰©å±•é˜…è¯»

### æ¨èä¹¦ç±
- ã€Šé‡åŒ–äº¤æ˜“ï¼šå¦‚ä½•å»ºç«‹è‡ªå·±çš„ç®—æ³•äº¤æ˜“äº‹ä¸šã€‹- Ernest P. Chan
- ã€Šæœºå™¨å­¦ä¹ ä¸èµ„äº§å®šä»·ã€‹- Stefan Nagel  
- ã€Šé‡‘èé£é™©ç®¡ç†ã€‹- Joel Bessis

### ç›¸å…³èµ„æº
- [QuantLib](https://www.quantlib.org/) - é‡åŒ–é‡‘èåº“
- [Zipline](https://github.com/quantopian/zipline) - ç®—æ³•äº¤æ˜“å›æµ‹å¼•æ“
- [PyAlgoTrade](https://github.com/gbeced/pyalgotrade) - Pythonç®—æ³•äº¤æ˜“åº“

---

*æœ¬æŒ‡å—å°†éšç€ç³»ç»ŸåŠŸèƒ½çš„å®Œå–„æŒç»­æ›´æ–°ï¼Œæ¬¢è¿åé¦ˆå’Œå»ºè®®ã€‚*